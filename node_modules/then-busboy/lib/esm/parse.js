import { IncomingMessage } from "http";
import Busboy from "busboy";
import merge from "lodash.merge";
import onFile from "./listener/onFile.js";
import onField from "./listener/onField.js";
import onFilesLimit from "./listener/onFilesLimit.js";
import onFieldsLimit from "./listener/onFieldsLimit.js";
import onPartsLimit from "./listener/onPartsLimit.js";
import isPlainObject from "./util/isPlainObject.js";
import map from "./util/mapListeners.js";
import { BodyEntries } from "./BodyEntries.js";
const initializers = {
    onFile,
    onField,
    onFilesLimit,
    onFieldsLimit,
    onPartsLimit
};
const defaults = {
    castTypes: true
};
export const parse = (request, options = {}) => new Promise((resolve, reject) => {
    if (!(request instanceof IncomingMessage)) {
        throw new TypeError("Expected request argument to be an instance of http.IncomingMessage.");
    }
    if (!isPlainObject(options)) {
        throw new TypeError("Expected options argument to be an object.");
    }
    const opts = merge({}, defaults, options, { headers: request.headers });
    const parser = new Busboy(opts);
    const entries = new BodyEntries();
    const listeners = map(initializers, fn => fn(opts, entries));
    function unsubscribe() {
        map(listeners, (fn, name) => parser.off(name, fn));
    }
    function onError(error) {
        unsubscribe();
        reject(error);
    }
    entries.once("finish", body => {
        unsubscribe();
        resolve(body);
    });
    const onBodyRead = () => entries.finish(true);
    map(listeners, (fn, name) => parser.on(name, fn));
    entries.once("error", onError);
    parser
        .once("error", onError)
        .once("finish", onBodyRead);
    request.pipe(parser);
});
