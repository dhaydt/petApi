"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const http_1 = require("http");
const busboy_1 = __importDefault(require("busboy"));
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const onFile_1 = __importDefault(require("./listener/onFile"));
const onField_1 = __importDefault(require("./listener/onField"));
const onFilesLimit_1 = __importDefault(require("./listener/onFilesLimit"));
const onFieldsLimit_1 = __importDefault(require("./listener/onFieldsLimit"));
const onPartsLimit_1 = __importDefault(require("./listener/onPartsLimit"));
const isPlainObject_1 = __importDefault(require("./util/isPlainObject"));
const mapListeners_1 = __importDefault(require("./util/mapListeners"));
const BodyEntries_1 = require("./BodyEntries");
const initializers = {
    onFile: onFile_1.default,
    onField: onField_1.default,
    onFilesLimit: onFilesLimit_1.default,
    onFieldsLimit: onFieldsLimit_1.default,
    onPartsLimit: onPartsLimit_1.default
};
const defaults = {
    castTypes: true
};
const parse = (request, options = {}) => new Promise((resolve, reject) => {
    if (!(request instanceof http_1.IncomingMessage)) {
        throw new TypeError("Expected request argument to be an instance of http.IncomingMessage.");
    }
    if (!isPlainObject_1.default(options)) {
        throw new TypeError("Expected options argument to be an object.");
    }
    const opts = lodash_merge_1.default({}, defaults, options, { headers: request.headers });
    const parser = new busboy_1.default(opts);
    const entries = new BodyEntries_1.BodyEntries();
    const listeners = mapListeners_1.default(initializers, fn => fn(opts, entries));
    function unsubscribe() {
        mapListeners_1.default(listeners, (fn, name) => parser.off(name, fn));
    }
    function onError(error) {
        unsubscribe();
        reject(error);
    }
    entries.once("finish", body => {
        unsubscribe();
        resolve(body);
    });
    const onBodyRead = () => entries.finish(true);
    mapListeners_1.default(listeners, (fn, name) => parser.on(name, fn));
    entries.once("error", onError);
    parser
        .once("error", onError)
        .once("finish", onBodyRead);
    request.pipe(parser);
});
exports.parse = parse;
